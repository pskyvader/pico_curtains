import ujson\r\nimport ure\r\nfrom components.esp.errors import http_response_parse_invalid\r\nfrom lib.logging import getLogger, handlers, StreamHandler\r\nclass response_parser:\r\n    log_file = "parserlog.txt"    def __init__(self):\r\n        self.logger_parser = getLogger("parser_module")\r\n        self.logger_parser.addHandler(handlers.RotatingFileHandler(self.log_file))\r\n        self.logger_parser.addHandler(StreamHandler())\r\n        self.line_separator = "\\r" + "\\n"\r\n        self.line_separator_raw = "\\\\r" + "\\\\n"    def parse_http(self, http_res):\r\n        if http_res == None:\r\n            return None, None, None\r\n        try:\r\n            partition_separator = "IP" + "D"\r\n            sub_separator = r"\\+" + partition_separator + r",\\d+:"\r\n            http_res = str(http_res)[1:-1]\r\n            self.logger_parser.debug("step 1")\r\n            parsed_res = (http_res).partition("+" + partition_separator + ",")\r\n            self.logger_parser.debug("partition: %s", parsed_res)\r\n            parsed_res = parsed_res[2]\r\n            self.logger_parser.debug("st\r\nep 2: %s", str(parsed_res))\r\n            parsed_res = parsed_res.split(self.line_separator_raw * 2)\r\n            self.logger_parser.debug("step 3 len: %s", str(len(parsed_res)))            self.logger_parser.debug("step 3: %s", str("".join(parsed_res[1:])))\r\n            body_str = ure.sub(sub_separator, "", str("".join(parsed_res[1:])))\r\n            self.logger_parser.debug("step 4: %s", parsed_res[0])            headers_str = ure.sub(sub_separator, "", (parsed_res[0])).partition(":")[2]\r\n            self.logger_parser.debug("step 5")\r\n            status_code = -1\r\n        except Exception as e:\r\n            self.logger_parser.exception("parse error: %s", str(e))\r\n            self.logger_parser.exception("args:%s", str(e.args))\r\n            self.logger_parser.exception("original:%s", http_res)\r\n            self.logger_parser.exception("trace:%s", str(e.__traceback__))\r\n            raise http_response_parse_invalid(e, http_res)        headers = {}\r\n        for line in headers_str.split(self.line_separator_raw):\r\n            if ":" in line:\r\n                key, value = line.split(":", 1)\r\n                headers[key.strip()] = value.strip()        content_type = headers.get("Content-Type", "").lower()\r\n        self.logger_parser.debug("content type: " + content_type)\r\n        body = self.content_parser(body_str, content_type)        for status in str(headers_str.partition(self.line_separator_raw)[0]).split():\r\n       \r\n     if status.isdigit():\r\n                status_code = int(status)        return headers, body, status_code    def content_parser(self, body_str, content_type):\r\n        if "text/html" in content_type:\r\n            # If content type is HTML, parse the body as an HTML document\r\n            try:\r\n                html_parser = HTMLParser()\r\n                return html_parser.parse_html(body_str).to_dict()\r\n            except Exception as e:\r\n                self.logger_parser.exception("HTML parse error: " + str(e))\r\n                return body_str\r\n        elif "application/json" in content_type:\r\n            body_str = body_str.replace(self.line_separator_raw, "")\r\n            self.logger_parser.debug("body_str: " + str(body_str))\r\n            try:\r\n                return ujson.loads(body_str)\r\n            except ValueError as e:\r\n                self.logger_parser.critical("JSON parse error: %s", str(e))\r\n                return body_str\r\n        else:\r\n            # If content type is HTML, parse the body as an HTML document\r\n            try:\r\n                return self.parse_file(body_str)\r\n            except Exception as e:\r\n                self.logger_parser.exception("file parse error: %s", str(e))\r\n                return body_str  # Fallback to a string if HTML parsing fails    def parse_file(self, text):\r\n        original_r = \'"\\r"\'\r\n        original_n = \'"\\n"\'\r\n        wildcard_r = "wildcardR"\r\n        wildcard_n =\r\n "wildcardN"\r\n        self.logger_parser.debug("file content unprocessed: %s", text)        file_content = wildcard_r.join(text.split(original_r))\r\n        file_content = wildcard_n.join(file_content.split(original_n))\r\n        file_content = self.line_separator.join(\r\n            file_content.split(self.line_separator_raw)\r\n        )\r\n        file_content = original_r.join(file_content.split(wildcard_r))\r\n        file_content = original_n.join(file_content.split(wildcard_n))        self.logger_parser.debug("file content: %s", file_content)\r\n        return file_content\r\nclass HTMLNode:\r\n    def __init__(self, tag, parent=None):\r\n        self.tag = tag\r\n        self.attributes = {}\r\n        self.children = []\r\n        self.parent = parent\r\n        self.content = None    def add_child(self, child):\r\n        self.children.append(child)    def set_attribute(self, name, value):\r\n        self.attributes[name] = value    def to_dict(self):\r\n        node_dict = {\r\n            "tag": self.tag,\r\n            "attributes": self.attributes,\r\n            "children": [child.to_dict() for child in self.children],\r\n            "content": self.content,\r\n        }\r\n        return node_dict\r\nclass HTMLParser:\r\n    def __init__(self):\r\n        self.root = None\r\n        self.current_node = None    def parse_html(self, html) -> HTMLNode:\r\n        self.root = None\r\n        self.current_node = None        start = 0\r\n        l\r\nength = len(html)        while start < length:\r\n            if html[start] == "<":\r\n                if html[start + 1] == "/":\r\n                    # Closing tag\r\n                    self._process_closing_tag(html, start)\r\n                    start += 1\r\n                else:\r\n                    # Opening tag\r\n                    start = self._process_opening_tag(html, start)\r\n            else:\r\n                # Text content\r\n                start = self._process_text_content(html, start)        if not self.root:\r\n            self.root = HTMLNode("#none")\r\n        return self.root    def _process_closing_tag(self, html, start):\r\n        end = html.find(">", start + 1)\r\n        tag = html[start + 2 : end]\r\n        if self.current_node and self.current_node.tag == tag:\r\n            self.current_node = self.current_node.parent    def _process_opening_tag(self, html, start):\r\n        end = html.find(">", start + 1)\r\n        tag = html[start + 1 : end]\r\n        node = HTMLNode(tag)\r\n        if self.current_node:\r\n            self.current_node.add_child(node)\r\n            node.parent = self.current_node\r\n        else:\r\n            self.root = node\r\n        self.current_node = node\r\n        return end + 1    def _process_text_content(self, html, start):\r\n        end = html.find("<", start)\r\n        content = html[start:end].strip()\r\n        if content:\r\n            text_node = HTMLNode("#text")\r\n            text_node.cont\r\nent = content\r\n            if self.current_node:\r\n                self.current_node.add_child(text_node)\r\n            else:\r\n                self.root = text_node\r\n        return end\r\n
